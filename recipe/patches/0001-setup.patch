From 3a29ca90e9366c6692656a6ee827c06eb3896b2a Mon Sep 17 00:00:00 2001
From: Steven <scrass@anaconda.com>
Date: Thu, 25 Sep 2025 16:08:36 -0600
Subject: [PATCH] Fix comprehensive Windows/MSVC build compatibility issues

- Make GCC compiler flags conditional (non-Windows only)
- Fix PyObject_HEAD syntax error in module.c
- Fix empty struct definition for MSVC compatibility
- Fix JSValue casting by avoiding unnecessary cast for MSVC
- Add comprehensive MSVC compatibility for cutils.h:
  * Replace GCC built-ins (__builtin_clz, __builtin_ctz, etc.) with MSVC intrinsics
  * Fix packed structs using MSVC pragma pack instead of __attribute__((packed))
  * Handle function attributes (printf format, always_inline, etc.)
  * Add MSVC-specific macros for likely/unlikely, force_inline, etc.
---
 module.c                   |  6 ++-
 setup.py                   | 12 ++++--
 upstream-quickjs/cutils.h  | 77 ++++++++++++++++++++++++++++++++++++++
 upstream-quickjs/quickjs.h | 10 +++++
 4 files changed, 99 insertions(+), 6 deletions(-)

diff --git a/module.c b/module.c
index fba11c3..bf06f2f 100644
--- a/module.c
+++ b/module.c
@@ -35,7 +35,7 @@ typedef struct {
 
 // The data of the type _quickjs.Object.
 typedef struct {
-	PyObject_HEAD;
+	PyObject_HEAD
 	RuntimeData *runtime_data;
 	JSValue object;
 } ObjectData;
@@ -354,7 +354,9 @@ static PyObject *test(PyObject *self, PyObject *args) {
 }
 
 // Global state of the module. Currently none.
-struct module_state {};
+struct module_state {
+	int dummy; // MSVC requires at least one member
+};
 
 // GC traversal.
 static int runtime_traverse(RuntimeData *self, visitproc visit, void *arg) {
diff --git a/setup.py b/setup.py
index 9d17af3..de7bf5e 100644
--- a/setup.py
+++ b/setup.py
@@ -6,6 +6,7 @@ from setuptools import setup, Extension
 
 CONFIG_VERSION = open("upstream-quickjs/VERSION").read().strip()
 extra_link_args: List[str] = []
+extra_compile_args: List[str] = []
 
 if sys.platform == "win32":
     # To build for Windows:
@@ -17,9 +18,12 @@ if sys.platform == "win32":
     # 3. The code below will moneky-patch distutils to work.
     import distutils.cygwinccompiler
     distutils.cygwinccompiler.get_msvcr = lambda: [] 
-    # Make sure that pthreads is linked statically, otherwise we run into problems
-    # on computers where it is not installed.
-    extra_link_args = ["-static"]
+    extra_link_args = ["-pthread"]
+    # Windows/MSVC doesn't support GCC-specific warning flags
+    extra_compile_args = []
+else:
+    # GCC-specific warning flags for non-Windows platforms
+    extra_compile_args = ["-Werror=incompatible-pointer-types"]
 
 
 def get_c_sources(include_headers=False):
@@ -54,7 +58,7 @@ _quickjs = Extension(
     # HACK.
     # See https://github.com/pypa/packaging-problems/issues/84.
     sources=get_c_sources(include_headers=("sdist" in sys.argv)),
-    extra_compile_args=["-Werror=incompatible-pointer-types"],
+    extra_compile_args=extra_compile_args,
     extra_link_args=extra_link_args)
 
 long_description = """
diff --git a/upstream-quickjs/cutils.h b/upstream-quickjs/cutils.h
index 31f7cd8..74e6452 100644
--- a/upstream-quickjs/cutils.h
+++ b/upstream-quickjs/cutils.h
@@ -28,14 +28,30 @@
 #include <stdlib.h>
 #include <inttypes.h>
 
+#ifdef _MSC_VER
+#include <intrin.h>  // For MSVC intrinsics
+#pragma intrinsic(_BitScanForward, _BitScanReverse)
+#ifdef _WIN64
+#pragma intrinsic(_BitScanForward64, _BitScanReverse64)
+#endif
+#endif
+
 /* set if CPU is big endian */
 #undef WORDS_BIGENDIAN
 
+#ifdef _MSC_VER
+#define likely(x)       (x)
+#define unlikely(x)     (x)
+#define force_inline __forceinline
+#define no_inline __declspec(noinline)
+#define __maybe_unused
+#else
 #define likely(x)       __builtin_expect(!!(x), 1)
 #define unlikely(x)     __builtin_expect(!!(x), 0)
 #define force_inline inline __attribute__((always_inline))
 #define no_inline __attribute__((noinline))
 #define __maybe_unused __attribute__((unused))
+#endif
 
 #define xglue(x, y) x ## y
 #define glue(x, y) xglue(x, y)
@@ -114,27 +130,83 @@ static inline int64_t min_int64(int64_t a, int64_t b)
 /* WARNING: undefined if a = 0 */
 static inline int clz32(unsigned int a)
 {
+#ifdef _MSC_VER
+    unsigned long index;
+    _BitScanReverse(&index, a);
+    return 31 - index;
+#else
     return __builtin_clz(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int clz64(uint64_t a)
 {
+#ifdef _MSC_VER
+#ifdef _WIN64
+    unsigned long index;
+    _BitScanReverse64(&index, a);
+    return 63 - index;
+#else
+    // For 32-bit MSVC, handle 64-bit values manually
+    if (a >> 32)
+        return clz32((unsigned int)(a >> 32));
+    else
+        return 32 + clz32((unsigned int)a);
+#endif
+#else
     return __builtin_clzll(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz32(unsigned int a)
 {
+#ifdef _MSC_VER
+    unsigned long index;
+    _BitScanForward(&index, a);
+    return index;
+#else
     return __builtin_ctz(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz64(uint64_t a)
 {
+#ifdef _MSC_VER
+#ifdef _WIN64
+    unsigned long index;
+    _BitScanForward64(&index, a);
+    return index;
+#else
+    // For 32-bit MSVC, handle 64-bit values manually
+    unsigned int low = (unsigned int)a;
+    if (low)
+        return ctz32(low);
+    else
+        return 32 + ctz32((unsigned int)(a >> 32));
+#endif
+#else
     return __builtin_ctzll(a);
+#endif
 }
 
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+struct packed_u64 {
+    uint64_t v;
+};
+
+struct packed_u32 {
+    uint32_t v;
+};
+
+struct packed_u16 {
+    uint16_t v;
+};
+#pragma pack(pop)
+#else
 struct __attribute__((packed)) packed_u64 {
     uint64_t v;
 };
@@ -146,6 +218,7 @@ struct __attribute__((packed)) packed_u32 {
 struct __attribute__((packed)) packed_u16 {
     uint16_t v;
 };
+#endif
 
 static inline uint64_t get_u64(const uint8_t *tab)
 {
@@ -262,8 +335,12 @@ static inline int dbuf_put_u64(DynBuf *s, uint64_t val)
 {
     return dbuf_put(s, (uint8_t *)&val, 8);
 }
+#ifdef _MSC_VER
+int dbuf_printf(DynBuf *s, const char *fmt, ...);
+#else
 int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
                                                       const char *fmt, ...);
+#endif
 void dbuf_free(DynBuf *s);
 static inline BOOL dbuf_error(DynBuf *s) {
     return s->error;
diff --git a/upstream-quickjs/quickjs.h b/upstream-quickjs/quickjs.h
index d4a5cd3..f859aa2 100644
--- a/upstream-quickjs/quickjs.h
+++ b/upstream-quickjs/quickjs.h
@@ -666,7 +666,12 @@ static inline JSValue JS_DupValue(JSContext *ctx, JSValueConst v)
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
+#ifdef _MSC_VER
+    // For MSVC, avoid the cast since JSValueConst and JSValue are the same type in default build
+    return v;
+#else
     return (JSValue)v;
+#endif
 }
 
 static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
@@ -675,7 +680,12 @@ static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
+#ifdef _MSC_VER
+    // For MSVC, avoid the cast since JSValueConst and JSValue are the same type in default build
+    return v;
+#else
     return (JSValue)v;
+#endif
 }
 
 int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
-- 
2.50.1 (Apple Git-155)

